# 100 Days DSA Roadmap

### Plan

Practice DSA for 100 days (hopefully continuous).

---

### Progress

Day 1 / Day 100

![Progress](https://img.shields.io/badge/Progress-1%20-blue)

---

### All Problem Statements

1. Given a list of integers and a target value, find two distinct indices whose values sum up to the target. Return the pair of indices
2. Given daily stock prices, determine the maximum profit achievable by choosing one day to buy and a later day to sell
3. Given a list of integers, determine whether any value appears more than once
4. Given two strings, determine if one is an anagram of the other by comparing character frequencies
5. Group a list of strings into collections where each group contains words that are anagrams of each other
6. Given a list of integers, return a new list where each element is the product of all other elements except itself
7. Given a list of integers, find the contiguous subarray with the largest possible sum
8. Given an array and a window size, compute the maximum value in every sliding window position
9. Find the longest substring of a given string that contains no repeating characters
10. Given a string and a number k, find the length of the longest substring where you can replace at most k characters to make all characters identical
11. Given two strings, return the smallest substring in the first string that contains all characters of the second string
12. Move all zeroes in an array to the end while maintaining the relative order of non-zero elements
13. Return all unique triplets in a list of integers that sum up to zero
14. Given heights representing vertical lines, determine the maximum area of water that can be trapped between two lines
15. Rotate a square matrix 90 degrees clockwise in place
16. Reverse a singly linked list
17. Merge two sorted linked lists into a single sorted linked list
18. Detect whether a cycle exists in a linked list using two pointers
19. Reorder a linked list such that nodes are rearranged into first, last, second, second-last pattern
20. Remove the nth node from the end of a linked list
21. Add two numbers represented by linked lists where each node contains a single digit
22. Design a data structure that supports LRU (Least Recently Used) cache functionality
23. Determine if a string containing parentheses and brackets is valid based on proper closure
24. Implement a stack that supports retrieving the minimum value in constant time
25. Evaluate an expression written in Reverse Polish Notation
26. Given daily temperatures, determine for each day how many days you must wait until a warmer temperature occurs
27. Perform an inorder traversal of a binary tree
28. Perform a level order traversal of a binary tree
29. Determine the maximum depth of a binary tree
30. Determine whether a binary tree is height-balanced
31. Compute the diameter (longest path) of a binary tree
32. Given a binary tree and a target sum, determine if a root-to-leaf path exists that equals the sum
33. Reconstruct a binary tree using preorder and inorder traversal arrays
34. Find the lowest common ancestor of two nodes in a binary search tree
35. Implement a BST iterator supporting next() and hasNext()
36. Serialize and deserialize a binary tree to and from a string
37. Find the kth largest element in an array using a heap
38. Merge k sorted linked lists into a single sorted linked list
39. Implement a trie supporting insertion and prefix-based search
40. Find all words from a list that can be formed in a grid by adjacent letter traversal using backtracking and a trie
41. Implement binary search to locate a target in a sorted array
42. Search for a value in a rotated sorted array in logarithmic time
43. Find the minimum element in a rotated sorted array
44. Determine the minimum integer eating speed required for completing tasks within a limited number of hours
45. Given two sorted arrays, compute the median of the combined dataset in logarithmic time
46. Generate all possible subsets of a given list of numbers
47. Generate all unique subsets accounting for possible duplicates
48. Generate all permutations of a list of numbers
49. Find all combinations of numbers that sum to a target, with unlimited reuse allowed
50. Find combinations summing to a target but each element may be used only once
51. Solve the N-Queens puzzle and return all valid board configurations
52. Solve a partially filled Sudoku grid ensuring all rules are met
53. Given a phone number digit string, return all possible letter combinations
54. Given an array, determine if you can reach the last index following jump lengths
55. Compute the minimum number of jumps required to reach the end of an array
56. Determine if a complete circular gas station route can be completed
57. Insert a new interval into a list of existing intervals while maintaining sorted order
58. Merge overlapping intervals into non-overlapping intervals
59. Given intervals, determine the minimum number to remove to avoid overlapping
60. Given balloon intervals, find the minimum arrows required to burst all balloons
61. Implement merge sort on a list of numbers
62. Implement quicksort with partitioning logic
63. Find the kth smallest element using the quickselect algorithm
64. Implement counting sort for integers within a known limited range
65. Find the element that appears more than half the time in an array
66. Find the unique element where every other element appears twice
67. Count the number of 1 bits in an integer
68. Reverse the bit representation of a 32-bit number
69. Determine if an integer is a power of two
70. Add two integers without using + or - using bit operations
71. Compute how many distinct ways you can climb stairs if each step can be 1 or 2
72. Determine max money that can be robbed without alerting police (adjacent houses prohibited)
73. Same as House Robber but houses arranged in a circle
74. Given coin denominations, compute minimum coins needed to make a total
75. Count the number of ways to make a certain amount using given coin denominations
76. Determine if an array can be partitioned into two subsets with equal sum
77. Implement unbounded knapsack using DP
78. Implement 0/1 knapsack using DP
79. Find the longest increasing subsequence in an array
80. Compute the longest common subsequence between two strings
81. Compute the minimum edit distance between two strings
82. Decode a digit string following mapping rules
83. Determine if a string can be segmented into dictionary words
84. Count palindromic substrings in a string
85. Find the longest palindromic substring
86. Count unique paths from top-left to bottom-right of a grid
87. Count unique paths considering obstacles in grid
88. Compute the minimum path sum in a grid
89. Find the minimum path total in a triangle
90. Count the number of paths in a binary tree that sum to a target
91. Find the k most frequent elements in a list
92. Determine if it is possible to complete all courses given prerequisites
93. Return a valid order of courses given prerequisites
94. Count how many islands exist in a 2D grid
95. Clone an undirected graph
96. Determine time for all oranges to rot given spreading rules
97. Find shortest transformation steps from one word to another using a dictionary
98. Determine the ordering of characters in an alien language
99. Design a URL shortening system supporting encoding and decoding
100. Find shortest path in a binary matrix using BFS

---

### Notes

Questions were ChatGPT generated, will change if not solvable as I move forward in this challenge.
